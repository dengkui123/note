<font face="微软雅黑" size=2>

## 知识点整理
- [知识点整理](#知识点整理)
  - [1、图像映射和CSS Sprites](#1图像映射和css-sprites)
  - [2、null和空字符串""的区别](#2null和空字符串的区别)
  - [3、axios数据请求](#3axios数据请求)
  - [4、vue-cli脚手架目录](#4vue-cli脚手架目录)
  - [5、views和conponents的区别](#5views和conponents的区别)
  - [6、vue规范相关](#6vue规范相关)
  - [7、router-link-active 与 router-link-exact-active 区别](#7router-link-active-与-router-link-exact-active-区别)
  - [8、字体引入方法](#8字体引入方法)
  - [9、插入svg图片](#9插入svg图片)
  - [10、上传图片](#10上传图片)
  - [11、下载图片](#11下载图片)
  - [12、http](#12http)
  - [13、CSS文字溢出省略](#13css文字溢出省略)
  - [14、监听产生滚动的元素](#14监听产生滚动的元素)
  - [15、处理相对时间](#15处理相对时间)
  - [16、lodash工具库](#16lodash工具库)
  - [17、json-bigint 第三方包](#17json-bigint-第三方包)
  - [18、cropperjs库](#18cropperjs库)
  - [19、关于接口参数类型](#19关于接口参数类型)
  - [20.防抖和节流](#20防抖和节流)
  - [21.css三角形](#21css三角形)
  - [22.移动端css初始化库](#22移动端css初始化库)
  - [22.移动端技术选型*](#22移动端技术选型)
  - [23.嵌套块元素塌陷-外边距合并](#23嵌套块元素塌陷-外边距合并)
  - [24.media媒体查询引入css资源](#24media媒体查询引入css资源)
  - [25.rem适配方案库](#25rem适配方案库)
  - [26.清除浮动](#26清除浮动)
  - [27. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？](#27-当你在浏览器中输入-googlecom-并且按下回车之后发生了什么)
  - [28. 图片懒加载](#28-图片懒加载)
  - [29. 点击按钮回到顶部](#29-点击按钮回到顶部)
  - [30.数字金额转化为中文金额](#30数字金额转化为中文金额)
### 1、图像映射和CSS Sprites
给图片部分位置或组图添加超链接，比分离图片的超链接性能好，更多内容参考MDN：[Sprites](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Images/Implementing_image_sprites_in_CSS)、[图像映射](https://developer.mozilla.org/zh-CN/docs/learn/HTML/Howto/Add_a_hit_map_on_top_of_an_image)。

### 2、null和空字符串""的区别
- null不指向任何对象，相当于没有任何值；而""代表一个长度为0的字符串。   
- null不分配内存空间，""会分配内存空间

```
console.log(0 == "");       //true
console.log(0 === "");      //false
console.log(null == "");    //false
console.log(0 == null);     //false
```
### 3、axios数据请求
```
// 为给定 ID 的 user 创建请求
axios.get('/user?ID=12345')
    .then(function(response){       //请求成功以后的回调函数 
      console.log(response);        //response包含后端返回的数据
      
    }).catch(function(error){       //请求失败以后的回调函数
        console.log(error);
    })
    
    
// 上面的请求也可以这样做
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

### 4、vue-cli脚手架目录

 整个项目目录结构：
![image](https://images2017.cnblogs.com/blog/916533/201801/916533-20180118181001443-1283702699.png)
 build文件夹目录结构：
![image](https://images2017.cnblogs.com/blog/916533/201801/916533-20180118181038803-812248862.png)
config文件夹下目录和文件:
![image](https://images2017.cnblogs.com/blog/916533/201801/916533-20180118181124068-169648827.png)

来源：**静静是小花**。  更多参考[vue-cli脚手架目录一览](https://www.cnblogs.com/hongdiandian/p/8311645.html)

### 5、views和conponents的区别

两个目录 ```src/components``` 和 ```src/views``` 均包含 Vue 组件。关键区别在于部分 Vue 组件在路由中扮演视图的作用：<br/>处理 Vue 路由通常使用```Vue Router```，路由是为了切换 ```<router-view>```组件的当前视图。这些路由通常被放在```src/router/index.js```。位于```src/components```目录下的组件很少被用于路由，而位于```src/views```目录下的组件将至少被一个路由使用。

> 有些人喜欢把视图文件放置于```src/router``` 下。<br/>
> 有些人喜欢将其置于```Pages```而不是```Views```。<br/>
> 有些人会把所有组件放到同一个文件夹下。

例如：
> 将所有路由组件放到```src/pages```中。在该目录中，我将为站点的每个“域”创建一个子目录。比如在```src/pages/questions```中，我将创建一个用于列表展示的```index.vue```。还会新增一个用于新增问题的 ```add.vue```组件等。这些“页面”通常都是通过简单的组件拼装而成的。在我的 ```src/components```目录下，我通常会创建一些子目录用于存放导航、表单元素、自定义的可共享组件等。

### 6、vue规范相关

事件名推荐用kabab-case

### 7、router-link-active 与 router-link-exact-active 区别

- router-link-exact-active 是精确匹配规则，即只有当前点击router被匹配
- router-link-active 默认是全包含匹配规则，即path名全包含在当前router path名开头的router也会被匹配到。
```
　1. <router-link to='/'>
　2. <router-link to='/a'>
　3. <router-link to='/b'>
　4. <router-link to='/ab'>
```
> 2、3号被选中的时候，1号也会被匹配到router-link-active；
> 4号被选中，1号2号两个也会被匹配到router-link-active。
> 可以通过在router添加exact属性改变为精确匹配。

```
<router-link to="/" exact>
//属性只会在地址为“/”的时候被激活
```

### 8、字体引入方法
1. 下载字体.ttf放到assets/font下(文件1)
1. 在font.css中引入字体（文件2）
1. main.js中引入font.css:（文件3）

    import './assets/scss/font.css'
    
font.css格式：
```
@font-face {
    font-famaly:"字体名";  (自定义名称)
    src:url('../font/字体.ttf');
}
```

### 9、插入svg图片

1、安装依赖包
npm install svg-sprite-loader --save-dev（[--save和--save-dev区别）](https://blog.csdn.net/cvper/article/details/88728505/)

详细步骤参考[[1]](https://www.jb51.net/article/204067.htm)[[2]](https://www.cnblogs.com/bluecaterpillar/p/13345444.html)

### 10、上传图片
[参考](https://blog.csdn.net/weixin_41941325/article/details/80764680)

**html：**
```
<div id="app">
  <div class="item_bock head_p">
     <div class="head_img">
       <img :src="userInfo.avatar"/>
       <--图片地址动态绑定-->
     </div>
     <div class="setting_right" @click.stop="uploadHeadImg">
       <div class="caption">更改头像</div>
     </div>
     <input type="file" accept="image/*" @change="handleFile" class="hiddenInput"/>
   </div>
 </div>
```
**tips:**
- 1.accept 属性用于限制图像的格式 如：（accept=”image/gif, image/jpeg”），accept=”image/*”表示不限制格式。
- 2.真正打开本地文件的是input，但这里是将其隐藏的。
- 
**js：**
```
var app = new Vue({
  el: '#app',
  data: {
    userInfo: {
      avatar: 'https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=62d46c39067b020818c437b303b099b6/d4628535e5dde7119c3d076aabefce1b9c1661ba.jpg'
    }
    // 初始图片
  },
  methods: {
    // 打开图片上传
    uploadHeadImg: function () {
      this.$el.querySelector('.hiddenInput').click()
    },
    // 将头像显示
    handleFile: function (e) {
      let $target = e.target || e.srcElement
      let file = $target.files[0]
      var reader = new FileReader()
      reader.onload = (data) => {
        let res = data.target || data.srcElement
        this.userInfo.avatar = res.result
      }
      reader.readAsDataURL(file)
    },
  }
})
```
**tips:**
- 1.this.$el.querySelector('.hiddenInput') 是获取文档中 class=”hiddenInput” 的元素。
- 2.在打开文件夹选中图片确认后，执行handleFile函数
- 3.let $target = e.target || e.srcElement 表示调用他的各种属性，两个的区别是：ie下支持e.srcElement，ff支持e.target。
- 4.由于手机上可以选择多张图片，所以let file = $target.files[0]，表示取第一张图。
- 5.var reader = new FileReader() FileReader对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。
- 6.onload 事件会在页面或图像加载完成后立即发生。
- 7.FileReader对象的readAsDataURL方法可以将读取到的文件编码成Data URL。

**css**
``` 
.item_bock {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height:94px;
  width: 300px;
  padding:0px 24px 0px 38px;
  border-bottom: 1px solid #f7f7f7;
  background: #fff;
}
.head_p {
  height:132px;
}
.head_img{
  height: 90px;
}
.head_img img{
  width:90px;
  height:90px;
  border-radius:50px
}
.setting_right{
  display: flex;
  height: 37px;
  justify-content: flex-end;
  align-items: center;
}
.hiddenInput{
  display: none;
}
.caption {
  color: #8F8F8F;
  font-size: 26px;
  height: 37px;
}
```
### 11、下载图片
```html
<el-dialog :title="title" :visible.sync="openfile" width="500px" append-to-body>
  <el-form ref="form1" :model="form1" :rules="rules">
    <img :src="form1.img"  style="width: 100%;height: 90%;" id="imageWrapper" />
    <el-button type="primary" @click="handleDown()" style="width: 100%;">下载图片</el-button>
  </el-form>
</el-dialog> 
```

```js
handleDown(){
  let link = document.createElement('a')
  let url =  this.form1.img  
  // 这里是将url转成blob地址，
  fetch(url).then(res => res.blob()).then(blob => { // 将链接地址字符内容转变成blob地址
    link.href = URL.createObjectURL(blob)
    link.download = 'pic'
    document.body.appendChild(link)
    link.click()
  })
},
```
### 12、http
<strong>URL：统一资源标识符</strong>，如：http://news.qq.com/a/20160209/012154.htm?a=1&b=2&c=3

- url组成：protocol、hostname、port、path、parameters
- protocol：协议。协议就是一套规则，定义了数据的封装、打包、拆包和解释的规则  	http://
- hostname：主机名/域名。可以将主机理解为一台名叫 news.qq.com 的机器，这台主机在 qq.com域名下。
- post：端口号。默认80，如：http://news.qq.com:8080/的端口号为8080
- path：路径。最终文件所在的路径和文件名，文件存储在服务器上.../a/20160209/012154.html/...
- parameters：查询、参数，如：a=1&b=2&c=3

<strong>GET和POST区别：原因：HTTP的规定和浏览器/服务器的限制，导致GET和POST有如下区别：</strong>
- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。

<strong>实际：GET和POST本质上就是TCP连接，并无差别。</strong>
- GET和POST是HTTP协议中的两种发送请求的方法。
- HTTP是基于TCP/IP的关于数据在万维网中如何通信的协议。
- HTTP的底层是TCP/IP，所以GET和POST的底层也是TCP/IP。

区别：GET产生一个TCP数据包；POST产生两个TCP数据包（不一定）。
> 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
> 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。（火狐除外，POST只发送一次）
> 理解：

> （1）如果客户端的请求头里面有这样的映射：Expect：100-continue，那么客户端先发送第一个包：请求头，并且阻塞读取服务端的回复。

> （2）然后服务端如果满足客户端的期望的话，会发送100continue，否则发送417.

> （3）客户端读取到服务器的状态行的响应码 如果是100 continue，那么客户端就得继续发送RequestBody，否则就结束请求。回到（1）这里，如果没有Expect的请求头，那么客户端不会先发送请求头的，会把请求头和RequestBody一起发送给服务器。

POST不能被GET取代的原因：
1. GET与POST都有自己的语义，不能随便混用
2. 在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

### 13、CSS文字溢出省略
- 单行：
```css
/* 不换行 */
white-space:nowrap;
/* 超出隐藏 */
overflow:hidden;
/* 省略号代替超出内容 */
text-overflow: ellipsis;
```
- 多行：
```css
overflow : hidden;
text-overflow: ellipsis;
/* 弹性伸缩盒子模型显示 */
display: -webkit-box;
/* 限制在一个块元素的文本行数 */
-webkit-line-clamp: 2;
/* 设置或检索伸缩盒对象的子元素的排列方式 */
-webkit-box-orient: vertical;
```     

### 14、监听产生滚动的元素
```js
function findScroller(element) {
  element.onscroll = function() {
    console.log(element);
  }
  Array.from(element.children).forEach(findScroller)
}

findScroller(document.body);
```

### 15、处理相对时间
**第三方库:**
- Moment.js
- Day.js

### 16、lodash工具库

`debounce(func, [wait=0],[options={}])`

创建一个 `debounced`（防抖动）函数，该函数会从上一次被调用后，延迟 `wait` 毫秒后调用 `func` 方法。 `debounced`（防抖动）函数提供一个 `cancel` 方法取消延迟的函数调用以及 `flush` 方法立即调用。 可以提供一个 `options`（选项） 对象决定如何调用 `func` 方法，`options.leading` 与|或 `options.trailing` 决定延迟前后如何触发（注：是 先调用后等待 还是 先等待后调用）。 `func` 调用时会传入最后一次提供给 `debounced`（防抖动）函数 的参数。 后续调用的 `debounced`（防抖动）函数返回是最后一次 `func` 调用的结果。

### 17、json-bigint 第三方包
- 处理数据中超出JS安全范围导致数据不准确的问题
```js
import JSONBig from 'json-bigint'
// JSONBig.parse()：把 JSON 格式的字符串转化为JS对象
// JSONBig.stringify()：把JS对象转化为JSON格式的字符串

let jsonStr =  '{"art_id": 12345678901234567}'
console.log(JSONBig.parse(jsonStr).art_id.toString())   //12345678901234567
```

### 18、cropperjs库
js下都可以使用的图片裁切库

```js
import 'cropperjs/dist/cropper.css';
import Cropper from 'cropperjs';
```
```html
<div>
  <img ref="img" class="img" :src="img">
</div> 
```
```js
//移动端裁切配置
mounted () {
    const image = this.$refs.img;
    const cropper = new Cropper(image, {
      viewMode: 1, // 裁剪框的范围 0可以拖出区域，1只能在画布中拖动
      dragMode: 'move', // 拖动模式
      aspectRatio: 1, // 裁切比例
      autoCropArea: 1, // 自动裁切尺寸 1代表最大
      cropBoxMovable: false, // 截图区域是否可以移动
      cropBoxResizable: false, // 截图区域是否可以缩放
      background: false, // 背景
      movable: true // 背景是否可以移动默认为true
    });
    console.log(cropper);
  },
```

### 19、关于接口参数类型
- 如果接口要求 Content-Type 是 application/json，则传递普通 JavaScript 对象
- 如果接口要求 Content-Type 是 multipart/form-data，则必须传递 FormData 对象

```js
const formData = new FormData();

// Pass the image file name as the third parameter if necessary.
formData.append('croppedImage', blob/*, 'example.png' */);

```

### 20.防抖和节流
> https://segmentfault.com/a/1190000018428170/
**防抖（debounce）**：将多次高频操作优化为只在最后一次操作执行。
>当事件被触发后，延迟n秒后再执行回调，如果在延迟期间再次触发事件，则重新计时。

使用场景：用户输入（模糊搜索）
```js
//防抖方法
//两个参数：fn函数（我们需要执行的操作）、delay（时间）
const debouned = (fn, delay) =>{
	//判断window上的times是否有值
    if (window.times){
    	//有值就清除（相当于终止了上次的setTimeout）
        clearTimeout(window.times)
    }
    //重新开启定时器
    window.times = setTimeout(() => {
    	//执行我们对应的操作
        fn()
    }, delay)
}
//调用防抖方法
debouned( () => {
	console.log('防抖')
}, 500 )
```
**节流**：每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作
使用场景：滚动事件、resize事件
```js
//节流方法
let timer, flag;
//三个参数：第二个和第三个可选
const throttle = (func, wait = 3000, immediate = true) => {
	if (immediate) {
		if (!flag) {
			flag = true;
			// 如果是立即执行，则在wait毫秒内开始时执行
			typeof func === 'function' && func();
			timer = setTimeout(() => {
				flag = false;
			}, wait);
			
		}
	} else {
		if (!flag) {
			flag = true
			// 如果是非立即执行，则在wait毫秒内的结束处执行
			timer = setTimeout(() => {
				flag = false
				typeof func === 'function' && func();
			}, wait);
		}
		
	}
};
throttle( () => {
console.log('节流')
} )

```
> 转自：winged Victory<br>
> 链接：https://blog.csdn.net/m0_53538943/article/details/118229174

练习：
```js
// test
// 防抖
let input = document.querySelector('.input');
let timer;
function debounce() {
  clearInterval(timer);
  timer = setTimeout(() => {
    console.log('hello world');
  },500);
}
input.onkeydown = () => debounce();
```

```js
// test
// 节流
function throttle() {
  let isListen = true;
  window.addEventListener('scroll', lazyLoad);
  window.addEventListener('resize', lazyLoad);
  function lazyLoad() {
    if (!isListen) return;
    isListen = false;
    setTimeout(() => {
      console.log(window.pageYOffset);
      console.log(window.innerHeight);
      isListen = true;
    }, 300)
  }
}
throttle();
```
### 21.css三角形
1.斜边三角形
```html
<div class="box"><div>
```
```css
.box {
  width: 0;
  height: 0;
  border-top: 100px solid transparent;
  border-right: 100px solid blue;
  border-bottom: 100px solid transparent;;
  border-left: 100px solid transparent;
}
```
2.直角三角形
```html
<div class="box"><div>
```
```css
.box {
  width: 0;
  height: 0;
  border-top: 100px solid transparent;
  border-right: 100px solid blue;
  border-bottom: 0 solid skyblue;
  border-left: 100px solid transparent;
}
```

### 22.移动端css初始化库
**normalize.css**

- 移动端样式解决方案
```css
/* CSS3盒子模型 */
box-sizing: border-box;
-webkit-box-sizing: border-box;
/* 清除点击高亮 设置为transparent透明 */
-webkit-tap-highlight-color: transparent;
/* 去除移动端按钮和输入框的样式 */
-webkit-appearance: none;
/* 禁用长按页面弹出菜单 */
img,a {
  -webkit-touch-callout: none;
}
```

### 22.移动端技术选型*
1. 单独制作移动端页面*
- 流式布局（百分比布局）
- flex 弹性布局（*）
- less + rem + 媒体查询布局
- 混合布局

2. 响应式页面兼容移动端
- 媒体查询
- bootstarp

### 23.嵌套块元素塌陷-外边距合并
解决方案：
1. 给父元素添加上边框
2. 给父元素定义内边距
3. 给父元素添加`overflow:hidden`
 
参考：https://www.jianshu.com/p/4473bffef8a0

### 24.media媒体查询引入css资源 
```css
<link rel="stylesheet" href="1.css" media="screen and (min-width: 320px)">

<link rel="stylesheet" href="1.css" media="screen and (min-width: 640px)">
```

### 25.rem适配方案库
`fleible.js`

### 26.清除浮动
1. :after 伪元素法
```css
.clearfix:after {
  content: "";
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}

.clearfix {   /* 兼容IE6、7 */
  *zoom: 1;
}

```  
2. 双伪元素法
```css
.clearfix:before,.clearfix:after {
  content: "";
  display: table;
}

.clearfix:after {
  clear: both;
}
.clearfix {
  *zoom: 1;
}

```

### 27. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？
```
（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入
的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向
本地 DNS服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根名服务器发起请求，获得负责的顶级域名服务器的地址后，再
向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将
这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下
发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC地址，
我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机
在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们
的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送
一个SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一
个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使
用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，
则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接
收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加
密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 
属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树
来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

（9）最后一步是 TCP 断开连接的四次挥手过程。
```

> 其他参考：https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst?utm_medium=social&utm_source=wechat_session&from=timeline&isappinstalled=0

### 28. 图片懒加载
监控浏览器的 scroll 事件，并且要计算图片与浏览器窗口的距离来选择替换图片的 src 地址。
```js
// HTML
<div>
  <img class="lazy-load" data-src="https://source.unsplash.com/random/600" alt="">
  <img class="lazy-load" data-src="https://source.unsplash.com/random/700" alt="">
  <img class="lazy-load" data-src="https://source.unsplash.com/random/800" alt="">
  <img class="lazy-load" data-src="https://source.unsplash.com/random/900" alt="">
</div>
// 引入 lodash 库
<script src="https://cdn.bootcss.com/lodash.js/4.17.12-pre/lodash.core.min.js"></script>
```  

```css
/* CSS */
div {
  margin-top: 350px;
}
.lazy-load {
  width: 200px;
  height: 150px;
}
```

```js
// JS
let lazyImages = [...document.querySelectorAll('.lazy-load')]
let inAdvance = 300
function lazyLoad() {
    lazyImages.forEach(image => {
        if (image.offsetTop < window.innerHeight + window.pageYOffset + inAdvance) {
            image.src = image.dataset.src;   // 替换真实图片的  URL
        }
    })
}
lazyLoad();
window.addEventListener('scroll', _.throttle(lazyLoad, 50))
window.addEventListener('resize', _.throttle(lazyLoad, 50))
```

这其中有几个属性，首先是 `data-src`，它是自定义属性，可以在 js 里通过 `dataset` 获得它的属性值；还有 `offsetTop` ,`innerHeight` 以及 `pageYOffset` 属性，你可以通过 MDN 文档查询他们的定义和用法；最后是 `_.throttle` 函数，它是一个节流函数，引用自 `lodash` 库，因为监听 `scroll` 滚动以及 `resize` 窗口改变事件会不断地触发，过于频繁，所以使用节流函数让其每隔一段时间执行，节省开销。

> offsetTop：当前对象到其上级层顶部的距离。<br>
> innerHeight：浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度。<br>
> pageYOffset 属性是 scrollY 属性的别名:返回文档在垂直方向已滚动的像素值。<br> 
> 为了跨浏览器兼容，请使用 window.pageYOffset 代替 window.scrollY。<br>
> getBoundingClientRect()//获取元素的大小及其相对视口位置。如getBoundingClientRect().top表示元素距离视口顶部的距离<br>
> 作者：一个学前端的码农<br>
> 链接：https://www.jianshu.com/p/c0f8cc330653

### 29. 点击按钮回到顶部
> 来源：https://www.cnblogs.com/jin-zhe/p/10506509.html
```html
<body style="height:2000px;">
  <button id="test" style="position:fixed;right:20px;bottom:20px">回到顶部</button>

<script>
　　test.onclick = function(){
      let timer = setInterval(() => {
        if(document.documentElement.scrollTop <= 0){
          clearInterval(timer);
          console.log('finished');
        }
        else if(document.documentElement.scrollTop <= 300) {
          document.body.scrollTop = document.documentElement.scrollTop -= 20;  
        }
        else{
          document.body.scrollTop = document.documentElement.scrollTop -= 100;  
        }
      }, 10);
　　}
</script>
</body>
```
### 30.数字金额转化为中文金额
```js
function numToString(num) {
  if(num > 999999999999) throw '超过金额上限，最大单位为千亿'
  const unitMap = ['','十','百','千','万','十','百','千','亿','十','百','千'];
  const stringMap = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九'];
  const numStr = num + '';
  let len = numStr.length;  //数字长度
  let lastIndex = len-1;  //最后一个数字的单位的索引
  let result = '';
  for(let i = 0; i < len; i++) {
    if (i < len-1 && numStr[i] == '0') {
      if(i === len- 9) {
        result += '亿';
      } else if (i === len - 5) {
        result += '万';
      } else if(numStr[i + 1] !== '0') {
        result += '零';
      }   
    } else {
      result += stringMap[numStr[i]] + unitMap[lastIndex];
    }
    lastIndex--;  
  }
  if(result[result.length-1] === '零') return result.slice(0,result.length-1);
  return result;
}
console.log(numToString(102034506709));
```