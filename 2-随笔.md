<font face="微软雅黑" size=2>

## 随笔
- [随笔](#随笔)
  - [1、图像映射和CSS Sprites](#1图像映射和css-sprites)
  - [2、null和空字符串""的区别](#2null和空字符串的区别)
  - [3、axios数据请求](#3axios数据请求)
  - [4、vue-cli脚手架目录](#4vue-cli脚手架目录)
  - [5、views和conponents的区别](#5views和conponents的区别)
  - [6、vue规范相关](#6vue规范相关)
  - [7、router-link-active 与 router-link-exact-active 区别](#7router-link-active-与-router-link-exact-active-区别)
  - [8、字体引入方法](#8字体引入方法)
  - [9、插入svg图片](#9插入svg图片)
  - [10、上传图片](#10上传图片)
  - [11、下载图片](#11下载图片)
  - [12、http](#12http)
  - [13、CSS文字溢出省略](#13css文字溢出省略)
  - [14、监听产生滚动的元素](#14监听产生滚动的元素)
  - [15、处理相对时间](#15处理相对时间)
  - [16、lodash工具库](#16lodash工具库)
  - [17、json-bigint 第三方包](#17json-bigint-第三方包)
  - [18、cropperjs库](#18cropperjs库)
  - [19、关于接口参数类型](#19关于接口参数类型)
  - [20.防抖](#20防抖)
  - [21.css三角形](#21css三角形)
  - [22.移动端css初始化库](#22移动端css初始化库)
  - [22.移动端技术选型*](#22移动端技术选型)
  - [23.嵌套块元素塌陷-外边距合并](#23嵌套块元素塌陷-外边距合并)
  - [24.media媒体查询引入css资源](#24media媒体查询引入css资源)
  - [25.rem适配方案库](#25rem适配方案库)
  - [26.清除浮动](#26清除浮动)
### 1、图像映射和CSS Sprites
给图片部分位置或组图添加超链接，比分离图片的超链接性能好，更多内容参考MDN：[Sprites](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Images/Implementing_image_sprites_in_CSS)、[图像映射](https://developer.mozilla.org/zh-CN/docs/learn/HTML/Howto/Add_a_hit_map_on_top_of_an_image)。

### 2、null和空字符串""的区别
- null不指向任何对象，相当于没有任何值；而""代表一个长度为0的字符串。   
- null不分配内存空间，""会分配内存空间

```
console.log(0 == "");       //true
console.log(0 === "");      //false
console.log(null == "");    //false
console.log(0 == null);     //false
```
### 3、axios数据请求
```
// 为给定 ID 的 user 创建请求
axios.get('/user?ID=12345')
    .then(function(response){       //请求成功以后的回调函数 
      console.log(response);        //response包含后端返回的数据
      
    }).catch(function(error){       //请求失败以后的回调函数
        console.log(error);
    })
    
    
// 上面的请求也可以这样做
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

### 4、vue-cli脚手架目录

 整个项目目录结构：
![image](https://images2017.cnblogs.com/blog/916533/201801/916533-20180118181001443-1283702699.png)
 build文件夹目录结构：
![image](https://images2017.cnblogs.com/blog/916533/201801/916533-20180118181038803-812248862.png)
config文件夹下目录和文件:
![image](https://images2017.cnblogs.com/blog/916533/201801/916533-20180118181124068-169648827.png)

来源：**静静是小花**。  更多参考[vue-cli脚手架目录一览](https://www.cnblogs.com/hongdiandian/p/8311645.html)

### 5、views和conponents的区别

两个目录 ```src/components``` 和 ```src/views``` 均包含 Vue 组件。关键区别在于部分 Vue 组件在路由中扮演视图的作用：<br/>处理 Vue 路由通常使用```Vue Router```，路由是为了切换 ```<router-view>```组件的当前视图。这些路由通常被放在```src/router/index.js```。位于```src/components```目录下的组件很少被用于路由，而位于```src/views```目录下的组件将至少被一个路由使用。

> 有些人喜欢把视图文件放置于```src/router``` 下。<br/>
> 有些人喜欢将其置于```Pages```而不是```Views```。<br/>
> 有些人会把所有组件放到同一个文件夹下。

例如：
> 将所有路由组件放到```src/pages```中。在该目录中，我将为站点的每个“域”创建一个子目录。比如在```src/pages/questions```中，我将创建一个用于列表展示的```index.vue```。还会新增一个用于新增问题的 ```add.vue```组件等。这些“页面”通常都是通过简单的组件拼装而成的。在我的 ```src/components```目录下，我通常会创建一些子目录用于存放导航、表单元素、自定义的可共享组件等。

### 6、vue规范相关

事件名推荐用kabab-case

### 7、router-link-active 与 router-link-exact-active 区别

- router-link-exact-active 是精确匹配规则，即只有当前点击router被匹配
- router-link-active 默认是全包含匹配规则，即path名全包含在当前router path名开头的router也会被匹配到。
```
　1. <router-link to='/'>
　2. <router-link to='/a'>
　3. <router-link to='/b'>
　4. <router-link to='/ab'>
```
> 2、3号被选中的时候，1号也会被匹配到router-link-active；
> 4号被选中，1号2号两个也会被匹配到router-link-active。
> 可以通过在router添加exact属性改变为精确匹配。

```
<router-link to="/" exact>
//属性只会在地址为“/”的时候被激活
```

### 8、字体引入方法
1. 下载字体.ttf放到assets/font下(文件1)
1. 在font.css中引入字体（文件2）
1. main.js中引入font.css:（文件3）

    import './assets/scss/font.css'
    
font.css格式：
```
@font-face {
    font-famaly:"字体名";  (自定义名称)
    src:url('../font/字体.ttf');
}
```

### 9、插入svg图片

1、安装依赖包
npm install svg-sprite-loader --save-dev（[--save和--save-dev区别）](https://blog.csdn.net/cvper/article/details/88728505/)

详细步骤参考[[1]](https://www.jb51.net/article/204067.htm)[[2]](https://www.cnblogs.com/bluecaterpillar/p/13345444.html)

### 10、上传图片
[参考](https://blog.csdn.net/weixin_41941325/article/details/80764680)

**html：**
```
<div id="app">
  <div class="item_bock head_p">
     <div class="head_img">
       <img :src="userInfo.avatar"/>
       <--图片地址动态绑定-->
     </div>
     <div class="setting_right" @click.stop="uploadHeadImg">
       <div class="caption">更改头像</div>
     </div>
     <input type="file" accept="image/*" @change="handleFile" class="hiddenInput"/>
   </div>
 </div>
```
**tips:**
- 1.accept 属性用于限制图像的格式 如：（accept=”image/gif, image/jpeg”），accept=”image/*”表示不限制格式。
- 2.真正打开本地文件的是input，但这里是将其隐藏的。
- 
**js：**
```
var app = new Vue({
  el: '#app',
  data: {
    userInfo: {
      avatar: 'https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=62d46c39067b020818c437b303b099b6/d4628535e5dde7119c3d076aabefce1b9c1661ba.jpg'
    }
    // 初始图片
  },
  methods: {
    // 打开图片上传
    uploadHeadImg: function () {
      this.$el.querySelector('.hiddenInput').click()
    },
    // 将头像显示
    handleFile: function (e) {
      let $target = e.target || e.srcElement
      let file = $target.files[0]
      var reader = new FileReader()
      reader.onload = (data) => {
        let res = data.target || data.srcElement
        this.userInfo.avatar = res.result
      }
      reader.readAsDataURL(file)
    },
  }
})
```
**tips:**
- 1.this.$el.querySelector('.hiddenInput') 是获取文档中 class=”hiddenInput” 的元素。
- 2.在打开文件夹选中图片确认后，执行handleFile函数
- 3.let $target = e.target || e.srcElement 表示调用他的各种属性，两个的区别是：ie下支持e.srcElement，ff支持e.target。
- 4.由于手机上可以选择多张图片，所以let file = $target.files[0]，表示取第一张图。
- 5.var reader = new FileReader() FileReader对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。
- 6.onload 事件会在页面或图像加载完成后立即发生。
- 7.FileReader对象的readAsDataURL方法可以将读取到的文件编码成Data URL。

**css**
``` 
.item_bock {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height:94px;
  width: 300px;
  padding:0px 24px 0px 38px;
  border-bottom: 1px solid #f7f7f7;
  background: #fff;
}
.head_p {
  height:132px;
}
.head_img{
  height: 90px;
}
.head_img img{
  width:90px;
  height:90px;
  border-radius:50px
}
.setting_right{
  display: flex;
  height: 37px;
  justify-content: flex-end;
  align-items: center;
}
.hiddenInput{
  display: none;
}
.caption {
  color: #8F8F8F;
  font-size: 26px;
  height: 37px;
}
```
### 11、下载图片
```html
<el-dialog :title="title" :visible.sync="openfile" width="500px" append-to-body>
  <el-form ref="form1" :model="form1" :rules="rules">
    <img :src="form1.img"  style="width: 100%;height: 90%;" id="imageWrapper" />
    <el-button type="primary" @click="handleDown()" style="width: 100%;">下载图片</el-button>
  </el-form>
</el-dialog> 
```

```js
handleDown(){
  let link = document.createElement('a')
  let url =  this.form1.img  
  // 这里是将url转成blob地址，
  fetch(url).then(res => res.blob()).then(blob => { // 将链接地址字符内容转变成blob地址
    link.href = URL.createObjectURL(blob)
    link.download = 'pic'
    document.body.appendChild(link)
    link.click()
  })
},
```
### 12、http
<strong>URL：统一资源标识符</strong>，如：http://news.qq.com/a/20160209/012154.htm?a=1&b=2&c=3

- url组成：protocol、hostname、port、path、parameters
- protocol：协议。协议就是一套规则，定义了数据的封装、打包、拆包和解释的规则  	http://
- hostname：主机名/域名。可以将主机理解为一台名叫 news.qq.com 的机器，这台主机在 qq.com域名下。
- post：端口号。默认80，如：http://news.qq.com:8080/的端口号为8080
- path：路径。最终文件所在的路径和文件名，文件存储在服务器上.../a/20160209/012154.html/...
- parameters：查询、参数，如：a=1&b=2&c=3

<strong>GET和POST区别：原因：HTTP的规定和浏览器/服务器的限制，导致GET和POST有如下区别：</strong>
- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。

<strong>实际：GET和POST本质上就是TCP连接，并无差别。</strong>
- GET和POST是HTTP协议中的两种发送请求的方法。
- HTTP是基于TCP/IP的关于数据在万维网中如何通信的协议。
- HTTP的底层是TCP/IP，所以GET和POST的底层也是TCP/IP。

区别：GET产生一个TCP数据包；POST产生两个TCP数据包（不一定）。
> 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
> 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。（火狐除外，POST只发送一次）
> 理解：

> （1）如果客户端的请求头里面有这样的映射：Expect：100-continue，那么客户端先发送第一个包：请求头，并且阻塞读取服务端的回复。

> （2）然后服务端如果满足客户端的期望的话，会发送100continue，否则发送417.

> （3）客户端读取到服务器的状态行的响应码 如果是100 continue，那么客户端就得继续发送RequestBody，否则就结束请求。回到（1）这里，如果没有Expect的请求头，那么客户端不会先发送请求头的，会把请求头和RequestBody一起发送给服务器。

POST不能被GET取代的原因：
1. GET与POST都有自己的语义，不能随便混用
2. 在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

### 13、CSS文字溢出省略
- 单行：
```css
/* 不换行 */
white-space:nowrap;
/* 超出隐藏 */
overflow:hidden;
/* 省略号代替超出内容 */
text-overflow: ellipsis;
```
- 多行：
```css
overflow : hidden;
text-overflow: ellipsis;
/* 弹性伸缩盒子模型显示 */
display: -webkit-box;
/* 限制在一个块元素的文本行数 */
-webkit-line-clamp: 2;
/* 设置或检索伸缩盒对象的子元素的排列方式 */
-webkit-box-orient: vertical;
```     

### 14、监听产生滚动的元素
```js
function findScroller(element) {
  element.onscroll = function() {
    console.log(element);
  }
  Array.from(element.children).forEach(findScroller)
}

findScroller(document.body);
```

### 15、处理相对时间
**第三方库:**
- Moment.js
- Day.js

### 16、lodash工具库

`debounce(func, [wait=0],[options={}])`

创建一个 `debounced`（防抖动）函数，该函数会从上一次被调用后，延迟 `wait` 毫秒后调用 `func` 方法。 `debounced`（防抖动）函数提供一个 `cancel` 方法取消延迟的函数调用以及 `flush` 方法立即调用。 可以提供一个 `options`（选项） 对象决定如何调用 `func` 方法，`options.leading` 与|或 `options.trailing` 决定延迟前后如何触发（注：是 先调用后等待 还是 先等待后调用）。 `func` 调用时会传入最后一次提供给 `debounced`（防抖动）函数 的参数。 后续调用的 `debounced`（防抖动）函数返回是最后一次 `func` 调用的结果。

### 17、json-bigint 第三方包
- 处理数据中超出JS安全范围导致数据不准确的问题
```js
import JSONBig from 'json-bigint'
// JSONBig.parse()：把 JSON 格式的字符串转化为JS对象
// JSONBig.stringify()：把JS对象转化为JSON格式的字符串

let jsonStr =  '{"art_id": 12345678901234567}'
console.log(JSONBig.parse(jsonStr).art_id.toString())   //12345678901234567
```

### 18、cropperjs库
js下都可以使用的图片裁切库

```js
import 'cropperjs/dist/cropper.css';
import Cropper from 'cropperjs';
```
```html
<div>
  <img ref="img" class="img" :src="img">
</div> 
```
```js
//移动端裁切配置
mounted () {
    const image = this.$refs.img;
    const cropper = new Cropper(image, {
      viewMode: 1, // 裁剪框的范围 0可以拖出区域，1只能在画布中拖动
      dragMode: 'move', // 拖动模式
      aspectRatio: 1, // 裁切比例
      autoCropArea: 1, // 自动裁切尺寸 1代表最大
      cropBoxMovable: false, // 截图区域是否可以移动
      cropBoxResizable: false, // 截图区域是否可以缩放
      background: false, // 背景
      movable: true // 背景是否可以移动默认为true
    });
    console.log(cropper);
  },
```

### 19、关于接口参数类型
- 如果接口要求 Content-Type 是 application/json，则传递普通 JavaScript 对象
- 如果接口要求 Content-Type 是 multipart/form-data，则必须传递 FormData 对象

```js
const formData = new FormData();

// Pass the image file name as the third parameter if necessary.
formData.append('croppedImage', blob/*, 'example.png' */);

```

### 20.防抖
**防抖（debounce）**：将多次高频操作优化为只在最后一次操作执行。
>当事件被触发后，延迟n秒后再执行回调，如果在延迟期间再次触发事件，则重新计时。

使用场景：用户输入（模糊搜索）
```js
//防抖方法
//两个参数：fn函数（我们需要执行的操作）、delay（时间）
const debouned = (fn, delay) =>{
	//判断window上的times是否有值
    if (window.times){
    	//有值就清除（相当于终止了上次的setTimeout）
        clearTimeout(window.times)
    }
    //重新开启定时器
    window.times = setTimeout(() => {
    	//执行我们对应的操作
        fn()
    }, delay)
}
//调用防抖方法
debouned( () => {
	console.log('防抖')
}, 500 )
```
**节流**：每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作
使用场景：滚动事件、resize事件
```js
//节流方法
let timer, flag;
//三个参数：第二个和第三个可选
const throttle = (func, wait = 3000, immediate = true) => {
	if (immediate) {
		if (!flag) {
			flag = true;
			// 如果是立即执行，则在wait毫秒内开始时执行
			typeof func === 'function' && func();
			timer = setTimeout(() => {
				flag = false;
			}, wait);
			
		}
	} else {
		if (!flag) {
			flag = true
			// 如果是非立即执行，则在wait毫秒内的结束处执行
			timer = setTimeout(() => {
				flag = false
				typeof func === 'function' && func();
			}, wait);
		}
		
	}
};
throttle( () => {
console.log('节流')
} )

```
> 转自：winged Victory<br>
> 链接：https://blog.csdn.net/m0_53538943/article/details/118229174

### 21.css三角形
1.斜边三角形
```html
<div class="box"><div>
```
```css
.box {
  width: 0;
  height: 0;
  border-top: 100px solid transparent;
  border-right: 100px solid blue;
  border-bottom: 100px solid transparent;;
  border-left: 100px solid transparent;
}
```
2.直角三角形
```html
<div class="box"><div>
```
```css
.box {
  width: 0;
  height: 0;
  border-top: 100px solid transparent;
  border-right: 100px solid blue;
  border-bottom: 0 solid skyblue;
  border-left: 100px solid transparent;
}
```

### 22.移动端css初始化库
**normalize.css**

- 移动端样式解决方案
```css
/* CSS3盒子模型 */
box-sizing: border-box;
-webkit-box-sizing: border-box;
/* 清除点击高亮 设置为transparent透明 */
-webkit-tap-highlight-color: transparent;
/* 去除移动端按钮和输入框的样式 */
-webkit-appearance: none;
/* 禁用长按页面弹出菜单 */
img,a {
  -webkit-touch-callout: none;
}
```

### 22.移动端技术选型*
1. 单独制作移动端页面*
- 流式布局（百分比布局）
- flex 弹性布局（*）
- less + rem + 媒体查询布局
- 混合布局

2. 响应式页面兼容移动端
- 媒体查询
- bootstarp

### 23.嵌套块元素塌陷-外边距合并
解决方案：
1. 给父元素添加上边框
2. 给父元素定义内边距
3. 给父元素添加`overflow:hidden`
 
参考：https://www.jianshu.com/p/4473bffef8a0

### 24.media媒体查询引入css资源 
```css
<link rel="stylesheet" href="1.css" media="screen and (min-width: 320px)">

<link rel="stylesheet" href="1.css" media="screen and (min-width: 640px)">
```

### 25.rem适配方案库
`fleible.js`

### 26.清除浮动
1. :after 伪元素法
```css
.clearfix:after {
  content: "";
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}

.clearfix {   /* 兼容IE6、7 */
  *zoom: 1;
}

```  
2. 双伪元素法
```css
.clearfix:before,.clearfix:after {
  content: "";
  display: table;
}

.clearfix:after {
  clear: both;
}
.clearfix {
  *zoom: 1;
}

```