<font size=2 face="微软雅黑">

## 优化

### 1、减少HTTP请求数
每个请求都是有成本的，既包 含时间成本也包含资源成本。
1. 时间成本：一个完整的请求都需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个“漫长”而复杂的过程。
2. 资源成本：由于浏览器进行并发请求的请求数是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间。

**减少请求的方法：**
1. 从设计实现层面简化页面
> 如果你的页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用时最直接的。如果不是这样，你的页面需要华丽的皮肤，则继续阅读下面的内容。

2. 合理设置HTTP缓存
> 缓存的力量是强大的，恰当的缓存设置可以大大的减少 `HTTP` 请求。以有啊首页为例，当浏览器没有缓存的时候访问一共会发出78个请求，共600多K 数据，而当第二次访问即浏览器已缓存之后访问则仅有10个请求，共20多K数据。<br>
> （这里需要说明的是，如果直接F5刷新页面 的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是304响应，只有 `Header` 没有 `Body` ，可以节省带宽）<br>
> 怎样才算合理设置？原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 `HTTP Header` 中的 `Expires` 设置一个很长的过期头；变化不频繁而又可能会变的资源可以使用 `Last-Modifed` 来做请求验证。尽可能的让资源能够 在缓存中待得更久。

3. 资源合并与压缩
> 如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外，`CSS`、`Javascript`、`Image`都可以用相应的工具进行压缩，压缩后往往能省下不少空间。

4. CSS Sprites
> 合并CSS图片，减少请求数的又一个好办法。

5. 图片懒加载（Lazy Load Images）
> 这条策略实际上并不一定能减少 `HTTP` 请求数，但是却能在某些条件下或者页面刚加载时减少 `HTTP` 请求数。对于图片而言，在页面刚加载的时候可以只 加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。有啊首页曾经的做法 是在加载的时候把第一屏之后的图片地址缓存在 `Textarea` 标签中，待用户往下滚屏的时候才“惰性”加载。

[图片懒加载示例](../../2-知识点整理.md#0)


### 2、重绘（Repaint）和回流（Reflow）
重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。
- **重绘** 是当节点需要更改外观而不会影响布局的，比如改变 color就叫称为重绘。
- **回流** 是布局或者几何属性需要改变就称为回流。

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。

所以以下几个动作可能会导致性能问题：
- 改变 `window` 大小
- 改变字体
- 添加或删除样式
- 文字改变
- 定位或者浮动
- 盒模型

重绘和回流其实和 Event loop 有关
1. 当 `Event loop` 执行完 `Microtasks` 后，会判断 `document` 是否需要更新。因为浏览器是 `60Hz` 的刷新率，每 `16ms` 才会更新一次。
2. 然后判断是否有 `resize` 或者 `scroll`，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 `16ms` 才会触发一次，并且自带节流功能。
3. 判断是否触发了 `media query`
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执行 `requestAnimationFrame` 回调
7. 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
8. 更新界面
9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调。

**减少重绘和回流**

**1. 使用 `translate` 替代 `top`**
- 使用 `translate` 时, `GPU` 进程会为其开启一个新的复合图层，不会影响默认复合图层（就是普通文档流），所以并不会影响周边的 `DOM` 结构，而属性的改变也会交给 `GPU` 处理，不会进行回流。

**2. 使用 `visibility` 替换 `display: none`，因为前者只会引起重绘，后者会引发回流（改变了布局）**

**3. 不要把 `DOM` 结点的属性值放在一个循环里当成循环里的变量**
```js
for(let i = 0; i < 1000; i++) {
  // 获取 offsetTop 会导致回流，因为需要去获取正确的值
  console.log(document.querySelector('.test').style.offsetTop)
}
```
**4. 不要使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重新布局**

**5. 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`**

**6. `CSS` 选择符从右往左匹配查找，避免 `DOM` 深度过深**

**7. 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video标签，浏览器会自动将该节点变为图层。**

### 3、为什么虚拟dom会提高性能?
虚拟 `dom` 相当于在 `js` 和真实 `dom` 中间加了一个缓存，利用 `dom diff` 算法避免了没有必要的 `dom` 操作，从而提高性能。

具体实现步骤如下：

1. 用 `JavaScript` 对象结构表示 `DOM` 树的结构；然后用这个树构建一个真正的 `DOM` 树，插到文档当中
2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
3. 把2所记录的差异应用到步骤1所构建的真正的 `DOM` 树上，视图就更新了。


> 来源：烟雨平生V<br>
> 链接：https://blog.csdn.net/sinat_37903468/article/details/100887223