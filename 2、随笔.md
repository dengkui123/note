<font size=3>

[toc]

## 随笔

### 1、图像映射和CSS Sprites
给图片部分位置或组图添加超链接，比分离图片的超链接性能好，更多内容参考MDN：[Sprites](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Images/Implementing_image_sprites_in_CSS)、[图像映射](https://developer.mozilla.org/zh-CN/docs/learn/HTML/Howto/Add_a_hit_map_on_top_of_an_image)。

### 2、null和空字符串""的区别
- null不指向任何对象，相当于没有任何值；而""代表一个长度为0的字符串。   
- null不分配内存空间，""会分配内存空间

```
console.log(0 == "");       //true
console.log(0 === "");      //false
console.log(null == "");    //false
console.log(0 == null);     //false
```
### 3、axios数据请求
```
// 为给定 ID 的 user 创建请求
axios.get('/user?ID=12345')
    .then(function(response){       //请求成功以后的回调函数 
      console.log(response);        //response包含后端返回的数据
      
    }).catch(function(error){       //请求失败以后的回调函数
        console.log(error);
    })
    
    
// 上面的请求也可以这样做
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

### 4、vue-cli脚手架目录

 整个项目目录结构：
![image](https://images2017.cnblogs.com/blog/916533/201801/916533-20180118181001443-1283702699.png)
 build文件夹目录结构：
![image](https://images2017.cnblogs.com/blog/916533/201801/916533-20180118181038803-812248862.png)
config文件夹下目录和文件:
![image](https://images2017.cnblogs.com/blog/916533/201801/916533-20180118181124068-169648827.png)

来源：**静静是小花**。  更多参考[vue-cli脚手架目录一览](https://www.cnblogs.com/hongdiandian/p/8311645.html)

### 5、views和conponents的区别

两个目录 ```src/components``` 和 ```src/views``` 均包含 Vue 组件。关键区别在于部分 Vue 组件在路由中扮演视图的作用：<br/>处理 Vue 路由通常使用```Vue Router```，路由是为了切换 ```<router-view>```组件的当前视图。这些路由通常被放在```src/router/index.js```。位于```src/components```目录下的组件很少被用于路由，而位于```src/views```目录下的组件将至少被一个路由使用。

> 有些人喜欢把视图文件放置于```src/router``` 下。<br/>
> 有些人喜欢将其置于```Pages```而不是```Views```。<br/>
> 有些人会把所有组件放到同一个文件夹下。

例如：
> 将所有路由组件放到```src/pages```中。在该目录中，我将为站点的每个“域”创建一个子目录。比如在```src/pages/questions```中，我将创建一个用于列表展示的```index.vue```。还会新增一个用于新增问题的 ```add.vue```组件等。这些“页面”通常都是通过简单的组件拼装而成的。在我的 ```src/components```目录下，我通常会创建一些子目录用于存放导航、表单元素、自定义的可共享组件等。

### 6、vue规范相关

事件名推荐用kabab-case

### 7、router-link-active 与 router-link-exact-active 区别

- router-link-exact-active 是精确匹配规则，即只有当前点击router被匹配
- router-link-active 默认是全包含匹配规则，即path名全包含在当前router path名开头的router也会被匹配到。
```
　1. <router-link to='/'>
　2. <router-link to='/a'>
　3. <router-link to='/b'>
　4. <router-link to='/ab'>
```
> 2、3号被选中的时候，1号也会被匹配到router-link-active；
> 4号被选中，1号2号两个也会被匹配到router-link-active。
> 可以通过在router添加exact属性改变为精确匹配。

```
<router-link to="/" exact>
//属性只会在地址为“/”的时候被激活
```

### 8、字体引入方法
1. 下载字体.ttf放到assets/font下(文件1)
1. 在font.css中引入字体（文件2）
1. main.js中引入font.css:（文件3）

    import './assets/scss/font.css'
    
font.css格式：
```
@font-face {
    font-famaly:"字体名";  (自定义名称)
    src:url('../font/字体.ttf');
}
```

### 9、插入svg图片

1、安装依赖包
npm install svg-sprite-loader --save-dev（[--save和--save-dev区别）](https://blog.csdn.net/cvper/article/details/88728505/)

详细步骤参考[[1]](https://www.jb51.net/article/204067.htm)[[2]](https://www.cnblogs.com/bluecaterpillar/p/13345444.html)

### 10、上传图片
[参考](https://blog.csdn.net/weixin_41941325/article/details/80764680)

**html：**
```
<div id="app">
  <div class="item_bock head_p">
     <div class="head_img">
       <img :src="userInfo.avatar"/>
       <--图片地址动态绑定-->
     </div>
     <div class="setting_right" @click.stop="uploadHeadImg">
       <div class="caption">更改头像</div>
     </div>
     <input type="file" accept="image/*" @change="handleFile" class="hiddenInput"/>
   </div>
 </div>
```
**tips:**
- 1.accept 属性用于限制图像的格式 如：（accept=”image/gif, image/jpeg”），accept=”image/*”表示不限制格式。
- 2.真正打开本地文件的是input，但这里是将其隐藏的。
- 
**js：**
```
var app = new Vue({
  el: '#app',
  data: {
    userInfo: {
      avatar: 'https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=62d46c39067b020818c437b303b099b6/d4628535e5dde7119c3d076aabefce1b9c1661ba.jpg'
    }
    // 初始图片
  },
  methods: {
    // 打开图片上传
    uploadHeadImg: function () {
      this.$el.querySelector('.hiddenInput').click()
    },
    // 将头像显示
    handleFile: function (e) {
      let $target = e.target || e.srcElement
      let file = $target.files[0]
      var reader = new FileReader()
      reader.onload = (data) => {
        let res = data.target || data.srcElement
        this.userInfo.avatar = res.result
      }
      reader.readAsDataURL(file)
    },
  }
})
```
**tips:**
- 1.this.$el.querySelector('.hiddenInput') 是获取文档中 class=”hiddenInput” 的元素。
- 2.在打开文件夹选中图片确认后，执行handleFile函数
- 3.let $target = e.target || e.srcElement 表示调用他的各种属性，两个的区别是：ie下支持e.srcElement，ff支持e.target。
- 4.由于手机上可以选择多张图片，所以let file = $target.files[0]，表示取第一张图。
- 5.var reader = new FileReader() FileReader对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。
- 6.onload 事件会在页面或图像加载完成后立即发生。
- 7.FileReader对象的readAsDataURL方法可以将读取到的文件编码成Data URL。

**css**
```
.item_bock {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height:94px;
  width: 300px;
  padding:0px 24px 0px 38px;
  border-bottom: 1px solid #f7f7f7;
  background: #fff;
}
.head_p {
  height:132px;
}
.head_img{
  height: 90px;
}
.head_img img{
  width:90px;
  height:90px;
  border-radius:50px
}
.setting_right{
  display: flex;
  height: 37px;
  justify-content: flex-end;
  align-items: center;
}
.hiddenInput{
  display: none;
}
.caption {
  color: #8F8F8F;
  font-size: 26px;
  height: 37px;
}
```

### 11、http
<strong>URL：统一资源标识符</strong>，如：http://news.qq.com/a/20160209/012154.htm?a=1&b=2&c=3

- url组成：protocol、hostname、port、path、parameters
- protocol：协议。协议就是一套规则，定义了数据的封装、打包、拆包和解释的规则  	http://
- hostname：主机名。可以将主机理解为一台名叫 news.qq.com 的机器，这台主机在 qq.com域名下。
- post：端口号。默认80，如：http://news.qq.com:8080/的端口号为8080
- path：路径。最终文件所在的路径和文件名，文件存储在服务器上.../a/20160209/012154.htm/...
- parameters：查询、参数，如：a=1&b=2&c=3

<strong>GET和POST区别：原因：HTTP的规定和浏览器/服务器的限制，导致GET和POST有如下区别：</strong>
- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。

<strong>实际：GET和POST本质上就是TCP连接，并无差别。</strong>
- GET和POST是HTTP协议中的两种发送请求的方法。
- HTTP是基于TCP/IP的关于数据在万维网中如何通信的协议。
- HTTP的底层是TCP/IP，所以GET和POST的底层也是TCP/IP。

区别：GET产生一个TCP数据包；POST产生两个TCP数据包（不一定）。
> 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
> 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。（火狐除外，POST只发送一次）
> 理解：

> （1）如果客户端的请求头里面有这样的映射：Expect：100-continue，那么客户端先发送第一个包：请求头，并且阻塞读取服务端的回复。

> （2）然后服务端如果满足客户端的期望的话，会发送100continue，否则发送417.

> （3）客户端读取到服务器的状态行的响应码 如果是100 continue，那么客户端就得继续发送RequestBody，否则就结束请求。回到（1）这里，如果没有Expect的请求头，那么客户端不会先发送请求头的，会把请求头和RequestBody一起发送给服务器。

POST不能被GET取代的原因：
1. GET与POST都有自己的语义，不能随便混用
2. 在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。